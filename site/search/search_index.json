{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>"},{"location":"#_1","title":"Home","text":"<p>Built with \u2665 by: Erik L. Hodges Ph.D. LinkedIn / GitHub </p> <p></p>"},{"location":"agents/","title":"agents","text":"<p>This module contains the Agent class, used in single-agent and multi-agent workflows.</p> <p>Classes:</p> Name Description <code>Agent</code> <p>Class for storing agent information.</p> <code>AgentConfig</code> <p>Class for storing agent configuration settings.</p> <p>Functions:</p> Name Description <code>create_agent</code> <p>Creates an agent with the given name.</p> <code>invoke_agent</code> <p>Invokes the agent with the given arguments and keyword arguments.</p>"},{"location":"agents/#libs.agents.Agent","title":"libs.agents.Agent  <code>dataclass</code>","text":"<pre><code>Agent(name='default', agent_config=None)\n</code></pre> <p>Class for storing agent information.</p> <p>Initializes the Agent with the given name and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the agent. Defaults to \"default\".</p> <code>'default'</code> <code>agent_config</code> <code>str</code> <p>The agent configuration name. Defaults to None.</p> <code>None</code> <p>Methods:</p> Name Description <code>change_status</code> <p>Changes the status of the agent.</p> <code>check_finished</code> <p>Checks if the agent has finished its task.</p> <code>fetch_content_for_review</code> <p>Fetches content for review if the agent is a reviewer.</p> <code>fetch_model_client</code> <p>Fetches the model client for the agent.</p> <code>fetch_project_name</code> <p>Fetches the project name.</p> <code>fetch_prompt_arg_vals</code> <p>Fetches the prompt argument values for the agent.</p> <code>fetch_team_name</code> <p>Fetches the team name.</p> <code>format_prompt</code> <p>Formats the prompt for the agent.</p> <code>get_status</code> <p>Gets the current status of the agent.</p> <code>invoke</code> <p>Invokes the agent to perform its task.</p> <code>log_agent</code> <p>Logs an event for the agent.</p> <code>parse_review</code> <p>Parses the review status from the agent's outputs.</p> Source code in <code>libs\\agents.py</code> <pre><code>def __init__(self, name: str = \"default\", agent_config: str = None) -&gt; None:\n    \"\"\"Initializes the Agent with the given name and configuration.\n\n    Args:\n        name (str): The name of the agent. Defaults to \"default\".\n        agent_config (str, optional): The agent configuration name. Defaults to None.\n    \"\"\"\n    self.name = name\n    if agent_config:\n        self.config = AgentConfig(agent_config)\n    else:\n        self.config = AgentConfig(name)\n    self.needs_review = self.config.needs_review\n    self.project = None\n    self.team = None\n    self.teammates = []\n    self.task = Task(persona=name)\n    self.finished = False\n    self.model = self.config.model\n    self.prompt = None\n    self.inputs = MessageLog()\n    self.outputs = MessageLog()\n    self.final_answer = None\n    self.status = {name: \"agent initialized\"}\n    self.tools = self.config.tools\n    self.event = Event(Target(get_class(self), self.name), self.status[name])\n    self.log = Log()\n    self.log.add(self.event)\n    self.fetch_model_client()\n</code></pre>"},{"location":"agents/#libs.agents.Agent.change_status","title":"libs.agents.Agent.change_status","text":"<pre><code>change_status(new_status)\n</code></pre> <p>Changes the status of the agent.</p> <p>Parameters:</p> Name Type Description Default <code>new_status</code> <code>str</code> <p>The new status of the agent.</p> required Source code in <code>libs\\agents.py</code> <pre><code>def change_status(self, new_status: str) -&gt; None:\n    \"\"\"Changes the status of the agent.\n\n    Args:\n        new_status (str): The new status of the agent.\n    \"\"\"\n    self.status[self.name] = new_status\n    self.log_agent(new_status)\n</code></pre>"},{"location":"agents/#libs.agents.Agent.check_finished","title":"libs.agents.Agent.check_finished","text":"<pre><code>check_finished()\n</code></pre> <p>Checks if the agent has finished its task.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The finished status.</p> Source code in <code>libs\\agents.py</code> <pre><code>def check_finished(self) -&gt; str:\n    \"\"\"Checks if the agent has finished its task.\n\n    Returns:\n        str: The finished status.\n    \"\"\"\n    is_finished = str(False)\n    try:\n        if self.inputs.last[\"message\"][\"pass_review\"]:\n            self.final_answer = self.outputs.last[\"message\"]\n            self.change_status(\"finished\")\n            self.finished = True\n            is_finished = \"True\"\n            self.team.members_finished.append(self.name)\n    except KeyError:\n        pass\n    return is_finished\n</code></pre>"},{"location":"agents/#libs.agents.Agent.fetch_content_for_review","title":"libs.agents.Agent.fetch_content_for_review","text":"<pre><code>fetch_content_for_review()\n</code></pre> <p>Fetches content for review if the agent is a reviewer.</p> Source code in <code>libs\\agents.py</code> <pre><code>def fetch_content_for_review(self) -&gt; None:\n    \"\"\"Fetches content for review if the agent is a reviewer.\"\"\"\n    if \"_reviewer\" in self.name:\n        try:\n            agent2review = self.name.replace(\"_reviewer\", \"\")\n            self.inputs.add_message(self.team.outputs.last[agent2review][\"message\"])\n        except KeyError:\n            print(\"unable to fetch content for review\")\n</code></pre>"},{"location":"agents/#libs.agents.Agent.fetch_model_client","title":"libs.agents.Agent.fetch_model_client","text":"<pre><code>fetch_model_client()\n</code></pre> <p>Fetches the model client for the agent.</p> Source code in <code>libs\\agents.py</code> <pre><code>def fetch_model_client(self) -&gt; None:\n    \"\"\"Fetches the model client for the agent.\"\"\"\n    self.model.instantiate_client(self.config)\n    self.log_agent(\"client initialized\")\n</code></pre>"},{"location":"agents/#libs.agents.Agent.fetch_project_name","title":"libs.agents.Agent.fetch_project_name","text":"<pre><code>fetch_project_name()\n</code></pre> <p>Fetches the project name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The project name.</p> Source code in <code>libs\\agents.py</code> <pre><code>def fetch_project_name(self) -&gt; str:\n    \"\"\"Fetches the project name.\n\n    Returns:\n        str: The project name.\n    \"\"\"\n    return self.project.name\n</code></pre>"},{"location":"agents/#libs.agents.Agent.fetch_prompt_arg_vals","title":"libs.agents.Agent.fetch_prompt_arg_vals","text":"<pre><code>fetch_prompt_arg_vals()\n</code></pre> <p>Fetches the prompt argument values for the agent.</p> Source code in <code>libs\\agents.py</code> <pre><code>def fetch_prompt_arg_vals(self) -&gt; None:\n    \"\"\"Fetches the prompt argument values for the agent.\"\"\"\n    self.config.prompt_arg_vals = {}\n    empty_data_types = {\n        str: \"\",\n        list: [],\n        dict: {},\n        type(None): None,\n    }\n    for arg in self.config.prompt_params:\n        arg_val = eval(arg)\n        if arg_val == empty_data_types[type(arg_val)]:\n            arg_val = \"None\"\n        self.config.prompt_arg_vals[strip_self_refs(arg)] = arg_val\n</code></pre>"},{"location":"agents/#libs.agents.Agent.fetch_team_name","title":"libs.agents.Agent.fetch_team_name","text":"<pre><code>fetch_team_name()\n</code></pre> <p>Fetches the team name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The team name.</p> Source code in <code>libs\\agents.py</code> <pre><code>def fetch_team_name(self) -&gt; str:\n    \"\"\"Fetches the team name.\n\n    Returns:\n        str: The team name.\n    \"\"\"\n    return self.team.name\n</code></pre>"},{"location":"agents/#libs.agents.Agent.format_prompt","title":"libs.agents.Agent.format_prompt","text":"<pre><code>format_prompt()\n</code></pre> <p>Formats the prompt for the agent.</p> Source code in <code>libs\\agents.py</code> <pre><code>def format_prompt(self) -&gt; None:\n    \"\"\"Formats the prompt for the agent.\"\"\"\n    self.fetch_prompt_arg_vals()\n    self.prompt = self.config.prompt_template.format(**self.config.prompt_arg_vals)\n</code></pre>"},{"location":"agents/#libs.agents.Agent.get_status","title":"libs.agents.Agent.get_status","text":"<pre><code>get_status()\n</code></pre> <p>Gets the current status of the agent.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The current status of the agent.</p> Source code in <code>libs\\agents.py</code> <pre><code>def get_status(self) -&gt; dict:\n    \"\"\"Gets the current status of the agent.\n\n    Returns:\n        dict: The current status of the agent.\n    \"\"\"\n    return self.status\n</code></pre>"},{"location":"agents/#libs.agents.Agent.invoke","title":"libs.agents.Agent.invoke","text":"<pre><code>invoke(*args, **kwargs)\n</code></pre> <p>Invokes the agent to perform its task.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The updated project and team information.</p> Source code in <code>libs\\agents.py</code> <pre><code>@traceable  # Auto-trace this function\ndef invoke(self, *args, **kwargs) -&gt; dict:\n    \"\"\"Invokes the agent to perform its task.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        dict: The updated project and team information.\n    \"\"\"\n    for arg in args:\n        pass\n    for kwarg in kwargs:\n        pass\n    # cur_kwargs = {name: kwargs.pop(name) for name in kwargs if name in kwargs}\n\n    self.check_finished()\n    if not self.finished:\n        self.team.update()\n        self.project.update()\n        self.fetch_content_for_review()\n        self.change_status(\"invoked\")\n        self.format_prompt()\n        full_response = self.model.client.invoke(self.prompt)\n        expected_response_type = self.config.response_format[\"type\"]\n        message = parse_agent_response(full_response, expected_response_type)\n        token_usage = json.dumps(full_response.response_metadata[\"token_usage\"])\n        self.outputs.add_message(message)\n        self.log_agent(f\"message: {message}\")\n        self.log_agent(f\"tokens: {token_usage}\")\n        self.change_status(\"responded\")\n        if not self.needs_review:\n            self.final_answer = self.outputs.last[\"message\"]\n            self.change_status(\"finished\")\n            self.finished = True\n    else:\n        full_response = self.outputs.last\n        message = self.final_answer\n    # TODO: Make sure I'm not overwriting the project state at this point\n    self.team.update()\n    self.project.update()\n    return {\"project\": self.project, \"team\": self.team}\n</code></pre>"},{"location":"agents/#libs.agents.Agent.log_agent","title":"libs.agents.Agent.log_agent","text":"<pre><code>log_agent(event_description)\n</code></pre> <p>Logs an event for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>event_description</code> <code>str</code> <p>The description of the event.</p> required Source code in <code>libs\\agents.py</code> <pre><code>def log_agent(self, event_description: str) -&gt; None:\n    \"\"\"Logs an event for the agent.\n\n    Args:\n        event_description (str): The description of the event.\n    \"\"\"\n    self.event = Event(Target(get_class(self), self.name), event_description)\n    self.log.add(self.event)\n</code></pre>"},{"location":"agents/#libs.agents.Agent.parse_review","title":"libs.agents.Agent.parse_review","text":"<pre><code>parse_review()\n</code></pre> <p>Parses the review status from the agent's outputs.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The review status.</p> Source code in <code>libs\\agents.py</code> <pre><code>def parse_review(self) -&gt; str:\n    \"\"\"Parses the review status from the agent's outputs.\n\n    Returns:\n        str: The review status.\n    \"\"\"\n    if self.outputs.last_message:\n        try:\n            pass_review = self.outputs.last_message[\"pass_review\"]\n        except KeyError:\n            pass_review = False\n    else:\n        pass_review = False\n\n    return str(pass_review)\n</code></pre>"},{"location":"agents/#libs.agents.AgentConfig","title":"libs.agents.AgentConfig  <code>dataclass</code>","text":"<pre><code>AgentConfig(name='default')\n</code></pre> <p>Class for storing agent configuration settings.</p> <p>Initializes the AgentConfig with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the agent configuration. Defaults to \"default\".</p> <code>'default'</code> <p>Methods:</p> Name Description <code>__print__</code> <p>Prints the agent configuration.</p> Source code in <code>libs\\agents.py</code> <pre><code>def __init__(self, name: str = \"default\") -&gt; None:\n    \"\"\"Initializes the AgentConfig with the given name.\n\n    Args:\n        name (str): The name of the agent configuration. Defaults to \"default\".\n    \"\"\"\n    agent_config = AGENTS[name]\n    agent_parameters = AGENTS[name][\"parameters\"]\n    self.priority = agent_config[\"priority\"]\n    self.needs_review = agent_config[\"needs_review\"]\n    self.model = Model(agent_config[\"model\"])\n    self.prompt_params = agent_config[\"prompt_params\"]\n    self.prompt_arg_vals = {}\n    self.prompt_template = agent_config[\"prompt_template\"]\n    self.response_format = agent_parameters.get(\"response_format\")\n    self.response_template = agent_config[\"response_template\"]\n    self.tools = agent_config[\"tools\"]\n    self.seed = agent_parameters[\"seed\"]\n    self.temperature = agent_parameters.get(\"temperature\")\n    self.top_p = agent_parameters.get(\"top_p\")\n    self.max_tokens = agent_parameters.get(\"max_tokens\")\n    self.max_retries = agent_parameters.get(\"max_retries\")\n    self.timeout = agent_parameters.get(\"timeout\")\n</code></pre>"},{"location":"agents/#libs.agents.AgentConfig.__print__","title":"libs.agents.AgentConfig.__print__","text":"<pre><code>__print__()\n</code></pre> <p>Prints the agent configuration.</p> Source code in <code>libs\\agents.py</code> <pre><code>def __print__(self) -&gt; None:\n    \"\"\"Prints the agent configuration.\"\"\"\n    return print(self.__dict__)\n</code></pre>"},{"location":"agents/#libs.agents.create_agent","title":"libs.agents.create_agent","text":"<pre><code>create_agent(agent_name)\n</code></pre> <p>Creates an agent with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>The name of the agent.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>The created agent and its model configuration.</p> Source code in <code>libs\\agents.py</code> <pre><code>def create_agent(agent_name: str) -&gt; tuple:\n    \"\"\"Creates an agent with the given name.\n\n    Args:\n        agent_name (str): The name of the agent.\n\n    Returns:\n        tuple: The created agent and its model configuration.\n    \"\"\"\n    print_heading(f\"Agent({repr(agent_name)}): Model Config\", \"green\")\n    agent = Agent(agent_name)\n    model_config = agent.config.model.__dict__\n    model_config = {\n        \"type\": model_config[\"type\"],\n        \"api\": model_config[\"api\"],\n        \"name\": model_config[\"name\"],\n        \"size\": model_config[\"size\"],\n        \"max_tokens\": agent.config.max_tokens,\n        \"temperature\": agent.config.temperature,\n        \"max_retries\": agent.config.max_retries,\n        \"timeout\": agent.config.timeout,\n        \"response_format\": agent.config.response_format,\n    }\n    print_dict(model_config, \"green\")\n    return agent, model_config\n</code></pre>"},{"location":"agents/#libs.agents.invoke_agent","title":"libs.agents.invoke_agent","text":"<pre><code>invoke_agent(agent, *args, **kwargs)\n</code></pre> <p>Invokes the agent with the given arguments and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent to be invoked.</p> required <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>The response and model artifact.</p> Source code in <code>libs\\agents.py</code> <pre><code>def invoke_agent(agent: Agent, *args, **kwargs) -&gt; tuple:\n    \"\"\"Invokes the agent with the given arguments and keyword arguments.\n\n    Args:\n        agent (Agent): The agent to be invoked.\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        tuple: The response and model artifact.\n    \"\"\"\n    model_config = kwargs.get(\"model_config\", None)\n    response_format = kwargs.get(\"response_format\", None)\n    prompt = kwargs.get(\"prompt\", None)\n    log_file_path = kwargs.get(\"log_file_path\", None)\n    save_log = kwargs.get(\"save_log\", None)\n\n    agent.config.response_format = response_format\n    agent.fetch_model_client()\n\n    full_response = agent.model.client.invoke(prompt)\n    response = full_response.__dict__\n    print_heading(\"Tokens\", \"blue\")\n    print_dict(full_response.usage_metadata, \"blue\")\n    print_heading(f\"Agent('{agent.name} - RESPONSE')\", \"green\")\n    print(colored(full_response.content, \"green\"))\n    print(\"\\n\")\n\n    if save_log:\n        log = read_file(log_file_path)\n        log = eval(log.replace(\"log = \", \"\"))\n        model_artifact = {\n            \"run_datetime\": Timestamp().iso,\n            \"model_config\": model_config,\n            \"user_prompt\": prompt,\n            \"final_response\": full_response.content,\n        }\n        log.append(model_artifact)\n        log_text = f\"log = {log}\"\n        write_file(log_text, log_file_path)\n    return response, model_artifact\n</code></pre>"},{"location":"common/","title":"common","text":"<p>Functions:</p> Name Description <code>cosine_similarity</code> <p>Get the cosine similarity between two vectors.</p> <code>describe_variable</code> <p>Describe a variable by printing its name and length.</p> <code>generate_random_name</code> <p>Generate a random name using the RandomWords library.</p> <code>get_class</code> <p>Return the class of a variable as a string.</p> <code>get_varname</code> <p>Return the name of a variable as a string.</p> <code>parse_agent_response</code> <p>Parse the agent response based on the expected response type.</p> <code>query_database</code> <p>Execute a query on the SQLite database.</p> <code>replace_in_dict</code> <p>Recursively replace placeholders in the dictionary values with variable values.</p> <code>replace_placeholders</code> <p>Replace placeholders in the text with actual variable values.</p> <code>strip_self_refs</code> <p>Replaces periods in self-references with underscores.</p>"},{"location":"common/#libs.utilities.common.cosine_similarity","title":"libs.utilities.common.cosine_similarity","text":"<pre><code>cosine_similarity(v1, v2)\n</code></pre> <p>Get the cosine similarity between two vectors.</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>ndarray</code> <p>The first vector.</p> required <code>v2</code> <code>ndarray</code> <p>The second vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The cosine similarity between the two vectors.</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def cosine_similarity(v1: np.ndarray, v2: np.ndarray) -&gt; float:\n    \"\"\"Get the cosine similarity between two vectors.\n\n    Args:\n        v1 (np.ndarray): The first vector.\n        v2 (np.ndarray): The second vector.\n\n    Returns:\n        float: The cosine similarity between the two vectors.\n    \"\"\"\n    return np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n</code></pre>"},{"location":"common/#libs.utilities.common.describe_variable","title":"libs.utilities.common.describe_variable","text":"<pre><code>describe_variable(variable)\n</code></pre> <p>Describe a variable by printing its name and length.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>object</code> <p>The variable to be described.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def describe_variable(variable: object) -&gt; None:\n    \"\"\"Describe a variable by printing its name and length.\n\n    Args:\n        variable (object): The variable to be described.\n\n    Returns:\n        None\n    \"\"\"\n    varname = get_varname(variable)\n    print(f\"{len(varname) = }\")\n    print(f\"{varname = }\")\n    return None\n</code></pre>"},{"location":"common/#libs.utilities.common.generate_random_name","title":"libs.utilities.common.generate_random_name","text":"<pre><code>generate_random_name()\n</code></pre> <p>Generate a random name using the RandomWords library.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A randomly generated name.</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def generate_random_name() -&gt; str:\n    \"\"\"Generate a random name using the RandomWords library.\n\n    Returns:\n        str: A randomly generated name.\n    \"\"\"\n    random_name = RandomWords().get_random_word()\n    return random_name\n</code></pre>"},{"location":"common/#libs.utilities.common.get_class","title":"libs.utilities.common.get_class","text":"<pre><code>get_class(variable)\n</code></pre> <p>Return the class of a variable as a string.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>object</code> <p>The variable whose class is to be retrieved.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The base class of the variable as a string.</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def get_class(variable: object) -&gt; str:\n    \"\"\"Return the class of a variable as a string.\n\n    Args:\n        variable (object): The variable whose class is to be retrieved.\n\n    Returns:\n        str: The base class of the variable as a string.\n    \"\"\"\n    base_class = str(type(variable)).replace(\"'&gt;\", \"\").split(\".\")[-1]\n    return base_class\n</code></pre>"},{"location":"common/#libs.utilities.common.get_varname","title":"libs.utilities.common.get_varname","text":"<pre><code>get_varname(variable)\n</code></pre> <p>Return the name of a variable as a string.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>object</code> <p>The variable whose name is to be retrieved.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the variable.</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def get_varname(variable: object) -&gt; str:\n    \"\"\"Return the name of a variable as a string.\n\n    Args:\n        variable (object): The variable whose name is to be retrieved.\n\n    Returns:\n        str: The name of the variable.\n    \"\"\"\n    callers_local_vars = inspect.currentframe().f_back.f_locals.items()\n    return [var_name for var_name, var_val in callers_local_vars if var_val is variable][0]\n</code></pre>"},{"location":"common/#libs.utilities.common.parse_agent_response","title":"libs.utilities.common.parse_agent_response","text":"<pre><code>parse_agent_response(full_response, expected_response_type)\n</code></pre> <p>Parse the agent response based on the expected response type.</p> <p>Parameters:</p> Name Type Description Default <code>full_response</code> <code>object</code> <p>The full response object.</p> required <code>expected_response_type</code> <code>str</code> <p>The expected type of the response (e.g., \"json_object\").</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The parsed message from the response.</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def parse_agent_response(full_response: object, expected_response_type: str) -&gt; str:\n    \"\"\"Parse the agent response based on the expected response type.\n\n    Args:\n        full_response (object): The full response object.\n        expected_response_type (str): The expected type of the response (e.g., \"json_object\").\n\n    Returns:\n        str: The parsed message from the response.\n    \"\"\"\n    if expected_response_type == \"json_object\":\n        try:\n            response_content = json.loads(full_response.content)\n            if response_content.get(\"response\"):\n                message = response_content.get(\"response\")\n            elif response_content.get(\"type\") == \"string\":\n                message = response_content.get(\"properties\").get(\"response\").get(\"description\")\n            elif response_content.get(\"type\") == \"object\":\n                message = response_content.get(\"properties\").get(\"response\").get(\"description\")\n            else:\n                message = full_response.content\n        except Exception as e:\n            message = full_response.content\n    else:\n        message = full_response.content\n    return message\n</code></pre>"},{"location":"common/#libs.utilities.common.query_database","title":"libs.utilities.common.query_database","text":"<pre><code>query_database(database, query)\n</code></pre> <p>Execute a query on the SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>Connection</code> <p>The SQLite database connection.</p> required <code>query</code> <code>str</code> <p>The SQL query to be executed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def query_database(database: sqlite3.Connection, query: str) -&gt; None:\n    \"\"\"Execute a query on the SQLite database.\n\n    Args:\n        database (sqlite3.Connection): The SQLite database connection.\n        query (str): The SQL query to be executed.\n\n    Returns:\n        None\n    \"\"\"\n    cursor = database.cursor()\n    try:\n        cursor.execute(query)\n        database.commit()\n        print(\"Query executed successfully\")\n    except sqlite3.Error as e:\n        print(f\"The error '{e}' occurred\")\n</code></pre>"},{"location":"common/#libs.utilities.common.replace_in_dict","title":"libs.utilities.common.replace_in_dict","text":"<pre><code>replace_in_dict(input_dict, variables)\n</code></pre> <p>Recursively replace placeholders in the dictionary values with variable values.</p> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>dict</code> <p>The input dictionary containing placeholders.</p> required <code>variables</code> <code>dict</code> <p>A dictionary of variable names and their values.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The input dictionary with placeholders replaced.</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def replace_in_dict(input_dict: dict, variables: dict) -&gt; dict:\n    \"\"\"Recursively replace placeholders in the dictionary values with variable values.\n\n    Args:\n        input_dict (dict): The input dictionary containing placeholders.\n        variables (dict): A dictionary of variable names and their values.\n\n    Returns:\n        dict: The input dictionary with placeholders replaced.\n    \"\"\"\n    for key, value in input_dict.items():\n        if isinstance(value, str):\n            input_dict[key] = replace_placeholders(value, variables)\n        elif isinstance(value, dict):\n            input_dict[key] = replace_in_dict(value, variables)\n        elif isinstance(value, list):\n            input_dict[key] = [\n                replace_placeholders(item, variables) if isinstance(item, str) else item\n                for item in value\n            ]\n\n    return input_dict\n</code></pre>"},{"location":"common/#libs.utilities.common.replace_placeholders","title":"libs.utilities.common.replace_placeholders","text":"<pre><code>replace_placeholders(text, variables)\n</code></pre> <p>Replace placeholders in the text with actual variable values.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text containing placeholders.</p> required <code>variables</code> <code>dict</code> <p>A dictionary of variable names and their values.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with placeholders replaced with variable values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a placeholder does not have a corresponding value in the dictionary.</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def replace_placeholders(text: str, variables: dict) -&gt; str:\n    \"\"\"Replace placeholders in the text with actual variable values.\n\n    Args:\n        text (str): The text containing placeholders.\n        variables (dict): A dictionary of variable names and their values.\n\n    Returns:\n        str: The text with placeholders replaced with variable values.\n\n    Raises:\n        ValueError: If a placeholder does not have a corresponding value in the dictionary.\n    \"\"\"\n    pattern = re.compile(r\"\\{(\\w+)\\}\")\n    matches = pattern.findall(text)\n\n    for match in matches:\n        if match in variables:\n            text = text.replace(\"{\" + match + \"}\", str(variables[match]))\n        else:\n            raise ValueError(f\"No replacement found for placeholder {{{match}}}\")\n\n    return text\n</code></pre>"},{"location":"common/#libs.utilities.common.strip_self_refs","title":"libs.utilities.common.strip_self_refs","text":"<pre><code>strip_self_refs(self_reference)\n</code></pre> <p>Replaces periods in self-references with underscores.</p> <p>Parameters:</p> Name Type Description Default <code>self_reference</code> <code>str</code> <p>The self-reference string to be modified.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The modified self-reference string.</p> Source code in <code>libs\\utilities\\common.py</code> <pre><code>def strip_self_refs(self_reference: str) -&gt; str:\n    \"\"\"Replaces periods in self-references with underscores.\n\n    Args:\n        self_reference (str): The self-reference string to be modified.\n\n    Returns:\n        str: The modified self-reference string.\n    \"\"\"\n    self_reference = self_reference.replace(\".\", \"_\")\n    return self_reference\n</code></pre>"},{"location":"core/","title":"core","text":"<p>This module contains the base and extended classes for general AI agent workflow development.</p> <p>Classes:</p> Name Description <code>Directories</code> <p>Class for handling directory paths related to the project.</p> <code>Event</code> <p>Class representing a single log entry.</p> <code>Log</code> <p>Class that maintains a history of events.</p> <code>MessageLog</code> <p>Class for storing agent messages.</p> <code>Target</code> <p>Class representing a single log entry.</p> <code>Task</code> <p>Class for storing task information.</p> <code>TeamMessageLog</code> <p>Class for storing team messages.</p> <code>Timestamp</code> <p>Class for creating and handling timestamps.</p>"},{"location":"core/#libs.core.Directories","title":"libs.core.Directories  <code>dataclass</code>","text":"<pre><code>Directories()\n</code></pre> <p>Class for handling directory paths related to the project.</p> <p>Initializes the Directories class with the given project name.</p> <p>Methods:</p> Name Description <code>get_directories</code> <p>Initializes and sets the directory paths.</p> Source code in <code>libs\\core.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the Directories class with the given project name.\n\n    Args:\n        None\n    \"\"\"\n    self.get_directories()\n</code></pre>"},{"location":"core/#libs.core.Directories.get_directories","title":"libs.core.Directories.get_directories","text":"<pre><code>get_directories()\n</code></pre> <p>Initializes and sets the directory paths.</p> Source code in <code>libs\\core.py</code> <pre><code>def get_directories(self) -&gt; None:\n    \"\"\"Initializes and sets the directory paths.\n\n    Args:\n        None\n    \"\"\"\n    self.root = os.getcwd()\n\n    self.libs = os.path.join(self.root, \"libs\")\n    self.security = os.path.join(self.root, \"security\")\n    self.configs = os.path.join(self.root, \"configs\")\n    self.models = os.path.join(self.root, \"models\")\n\n    self.data = os.path.join(self.root, \"data\")\n    self.docs = os.path.join(self.data, \"docs\")\n    self.databases = os.path.join(self.data, \"databases\")\n    self.logs = os.path.join(self.data, \"logs\")\n    self.inputs = os.path.join(self.data, \"inputs\")\n    self.outputs = os.path.join(self.data, \"outputs\")\n    self.out_files = os.path.join(self.outputs, \"files\")\n</code></pre>"},{"location":"core/#libs.core.Event","title":"libs.core.Event  <code>dataclass</code>","text":"<pre><code>Event(target, action)\n</code></pre> <p>Class representing a single log entry.</p> <p>Initializes the Event class.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Target</code> <p>The target of the event.</p> required <code>action</code> <code>str</code> <p>The description of the event.</p> required <p>Methods:</p> Name Description <code>unpack</code> <p>Unpacks the event details into a dictionary.</p> Source code in <code>libs\\core.py</code> <pre><code>def __init__(self, target: Target, action: str) -&gt; None:\n    \"\"\"Initializes the Event class.\n\n    Args:\n        target (Target): The target of the event.\n        action (str): The description of the event.\n    \"\"\"\n    self.timestamp = Timestamp().iso\n    self.target = f\"{target.type}('{target.name}')\"\n    self.event = action\n</code></pre>"},{"location":"core/#libs.core.Event.unpack","title":"libs.core.Event.unpack","text":"<pre><code>unpack()\n</code></pre> <p>Unpacks the event details into a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the event details.</p> Source code in <code>libs\\core.py</code> <pre><code>def unpack(self) -&gt; dict:\n    \"\"\"Unpacks the event details into a dictionary.\n\n    Returns:\n        dict: A dictionary containing the event details.\n    \"\"\"\n    return {\"timestamp\": self.timestamp, \"target\": self.target, \"event\": self.event}\n</code></pre>"},{"location":"core/#libs.core.Log","title":"libs.core.Log  <code>dataclass</code>","text":"<pre><code>Log()\n</code></pre> <p>Class that maintains a history of events.</p> <p>Initializes the Log class.</p> <p>Methods:</p> Name Description <code>add</code> <p>Records an event in the log.</p> <code>search</code> <p>Searches the log for events with a specific description.</p> <code>search_log_targets</code> <p>Searches the log for events with a specific target.</p> <code>update_last</code> <p>Updates the last event in the log.</p> Source code in <code>libs\\core.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the Log class.\"\"\"\n    event = Event(Target(get_class(self), \"Log\"), \"started\")\n    self.history = [\n        {\"timestamp\": event.timestamp, \"target\": event.target, \"event\": event.event}\n    ]\n    self.last = self.history[-1]\n</code></pre>"},{"location":"core/#libs.core.Log.add","title":"libs.core.Log.add","text":"<pre><code>add(event)\n</code></pre> <p>Records an event in the log.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event to be recorded.</p> required Source code in <code>libs\\core.py</code> <pre><code>def add(self, event: Event) -&gt; None:\n    \"\"\"Records an event in the log.\n\n    Args:\n        event (Event): The event to be recorded.\n    \"\"\"\n    self.history.append(event.unpack())\n    self.update_last()\n</code></pre>"},{"location":"core/#libs.core.Log.search","title":"libs.core.Log.search","text":"<pre><code>search(term)\n</code></pre> <p>Searches the log for events with a specific description.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>The term to search for in the event description.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of log events that match the search term.</p> Source code in <code>libs\\core.py</code> <pre><code>def search(self, term: str) -&gt; list:\n    \"\"\"Searches the log for events with a specific description.\n\n    Args:\n        term (str): The term to search for in the event description.\n\n    Returns:\n        list: A list of log events that match the search term.\n    \"\"\"\n    search_results = []\n    for idx, log_event in enumerate(self.history):\n        if term in log_event[\"event\"]:\n            search_results.append(log_event)\n    return search_results\n</code></pre>"},{"location":"core/#libs.core.Log.search_log_targets","title":"libs.core.Log.search_log_targets","text":"<pre><code>search_log_targets(term)\n</code></pre> <p>Searches the log for events with a specific target.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>The term to search for in the target.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of log events that match the search term.</p> Source code in <code>libs\\core.py</code> <pre><code>def search_log_targets(self, term: str) -&gt; list:\n    \"\"\"Searches the log for events with a specific target.\n\n    Args:\n        term (str): The term to search for in the target.\n\n    Returns:\n        list: A list of log events that match the search term.\n    \"\"\"\n    log_search_results = []\n    for idx, log_event in enumerate(self.history):\n        if term in log_event[\"target\"]:\n            log_search_results.append(log_event)\n    return log_search_results\n</code></pre>"},{"location":"core/#libs.core.Log.update_last","title":"libs.core.Log.update_last","text":"<pre><code>update_last()\n</code></pre> <p>Updates the last event in the log.</p> Source code in <code>libs\\core.py</code> <pre><code>def update_last(self) -&gt; None:\n    \"\"\"Updates the last event in the log.\"\"\"\n    self.last = self.history[-1]\n</code></pre>"},{"location":"core/#libs.core.MessageLog","title":"libs.core.MessageLog  <code>dataclass</code>","text":"<pre><code>MessageLog()\n</code></pre> <p>Class for storing agent messages.</p> <p>Initializes the MessageLog class.</p> <p>Methods:</p> Name Description <code>add_message</code> <p>Adds a message to the log.</p> <code>search_messages</code> <p>Searches the log for messages containing a specific term.</p> <code>update_last</code> <p>Updates the last message in the log.</p> Source code in <code>libs\\core.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the MessageLog class.\"\"\"\n    self.history = []\n    self.last = {}\n    self.last_message = None\n</code></pre>"},{"location":"core/#libs.core.MessageLog.add_message","title":"libs.core.MessageLog.add_message","text":"<pre><code>add_message(message)\n</code></pre> <p>Adds a message to the log.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to be added.</p> required Source code in <code>libs\\core.py</code> <pre><code>def add_message(self, message: str) -&gt; None:\n    \"\"\"Adds a message to the log.\n\n    Args:\n        message (str): The message to be added.\n    \"\"\"\n    self.history.append(\n        {\n            \"timestamp\": Timestamp().iso,\n            \"message\": message,\n        }\n    )\n    self.update_last()\n</code></pre>"},{"location":"core/#libs.core.MessageLog.search_messages","title":"libs.core.MessageLog.search_messages","text":"<pre><code>search_messages(term)\n</code></pre> <p>Searches the log for messages containing a specific term.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>The term to search for in the messages.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of messages that match the search term.</p> Source code in <code>libs\\core.py</code> <pre><code>def search_messages(self, term: str) -&gt; list:\n    \"\"\"Searches the log for messages containing a specific term.\n\n    Args:\n        term (str): The term to search for in the messages.\n\n    Returns:\n        list: A list of messages that match the search term.\n    \"\"\"\n    message_search_results = []\n    for msg_idx, message in enumerate(self.history):\n        if term in message[\"message\"]:\n            message_search_results.append(self.history[msg_idx])\n    return message_search_results\n</code></pre>"},{"location":"core/#libs.core.MessageLog.update_last","title":"libs.core.MessageLog.update_last","text":"<pre><code>update_last()\n</code></pre> <p>Updates the last message in the log.</p> Source code in <code>libs\\core.py</code> <pre><code>def update_last(self) -&gt; None:\n    \"\"\"Updates the last message in the log.\"\"\"\n    self.last = self.history[-1]\n    self.last_message = self.last[\"message\"] or None\n</code></pre>"},{"location":"core/#libs.core.Target","title":"libs.core.Target  <code>dataclass</code>","text":"<pre><code>Target(target_class, name)\n</code></pre> <p>Class representing a single log entry.</p> <p>Initializes the Target class.</p> <p>Parameters:</p> Name Type Description Default <code>target_class</code> <code>str</code> <p>The class of the target.</p> required <code>name</code> <code>str</code> <p>The name of the target.</p> required Source code in <code>libs\\core.py</code> <pre><code>def __init__(self, target_class: str, name: str) -&gt; None:\n    \"\"\"Initializes the Target class.\n\n    Args:\n        target_class (str): The class of the target.\n        name (str): The name of the target.\n    \"\"\"\n    self.type = target_class\n    self.name = name\n</code></pre>"},{"location":"core/#libs.core.Task","title":"libs.core.Task  <code>dataclass</code>","text":"<pre><code>Task(persona='default', assignee='task_manager', **kwargs)\n</code></pre> <p>Class for storing task information.</p> <p>Methods:</p> Name Description <code>prioritize</code> <p>Sets the task to highest priority.</p> <code>set_finished</code> <p>Sets the task to finished.</p> Source code in <code>libs\\core.py</code> <pre><code>def __init__(\n    self,\n    persona: str = \"default\",\n    assignee=\"task_manager\",\n    **kwargs,\n):\n\n    self.name = str(uuid4())\n    self.priority = 1\n    self.assignee = assignee\n    self.finished = False\n    if kwargs.get(\"objective\", None):\n        self.objective = kwargs.get(\"objective\")\n    else:\n        try:\n            self.objective = TASKS[persona]\n        except:\n            self.objective = TASKS[\"default\"]\n    self.event = Event(\n        Target(get_class(self), self.name), f\"objective created: {self.objective}\"\n    )\n    self.log = Log()\n    ###def __post_init__(self):\n    self.log.add(self.event)\n</code></pre>"},{"location":"core/#libs.core.Task.prioritize","title":"libs.core.Task.prioritize","text":"<pre><code>prioritize()\n</code></pre> <p>Sets the task to highest priority.</p> Source code in <code>libs\\core.py</code> <pre><code>def prioritize(self):\n    \"\"\"Sets the task to highest priority.\"\"\"\n    self.priority = 0\n    self.event = Event(Target(get_class(self), self.name), \"task prioritized\")\n    self.log.add(self.event)\n</code></pre>"},{"location":"core/#libs.core.Task.set_finished","title":"libs.core.Task.set_finished","text":"<pre><code>set_finished()\n</code></pre> <p>Sets the task to finished.</p> Source code in <code>libs\\core.py</code> <pre><code>def set_finished(self):\n    \"\"\"Sets the task to finished.\"\"\"\n    self.priority = 1\n    self.finished = True\n    self.event = Event(Target(get_class(self), self.name), \"task finished\")\n    self.log.add(self.event)\n</code></pre>"},{"location":"core/#libs.core.TeamMessageLog","title":"libs.core.TeamMessageLog  <code>dataclass</code>","text":"<pre><code>TeamMessageLog()\n</code></pre> <p>Class for storing team messages.</p> <p>Initializes the TeamMessageLog class.</p> <p>Methods:</p> Name Description <code>search_team_messages_content</code> <p>Searches the group messages for content containing a specific term.</p> Source code in <code>libs\\core.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the TeamMessageLog class.\"\"\"\n    self.history = {}\n    self.last = {}\n</code></pre>"},{"location":"core/#libs.core.TeamMessageLog.search_team_messages_content","title":"libs.core.TeamMessageLog.search_team_messages_content","text":"<pre><code>search_team_messages_content(term)\n</code></pre> <p>Searches the group messages for content containing a specific term.</p> <p>Parameters:</p> Name Type Description Default <code>term</code> <code>str</code> <p>The term to search for in the group messages.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of group messages that match the search term.</p> Source code in <code>libs\\core.py</code> <pre><code>def search_team_messages_content(self, term: str) -&gt; list:\n    \"\"\"Searches the group messages for content containing a specific term.\n\n    Args:\n        term (str): The term to search for in the group messages.\n\n    Returns:\n        list: A list of group messages that match the search term.\n    \"\"\"\n    team_message_search_results = []\n    for msg_idx, message in enumerate(self.history):\n        if term in message[\"message\"]:\n            team_message_search_results.append(self.history[msg_idx])\n    return team_message_search_results\n</code></pre>"},{"location":"core/#libs.core.Timestamp","title":"libs.core.Timestamp  <code>dataclass</code>","text":"<pre><code>Timestamp()\n</code></pre> <p>Class for creating and handling timestamps.</p> <p>Initializes the Timestamp class.</p> <p>Methods:</p> Name Description <code>create</code> <p>Generates the current time in various formats.</p> Source code in <code>libs\\core.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the Timestamp class.\"\"\"\n    self.create()\n</code></pre>"},{"location":"core/#libs.core.Timestamp.create","title":"libs.core.Timestamp.create","text":"<pre><code>create()\n</code></pre> <p>Generates the current time in various formats.</p> Source code in <code>libs\\core.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"Generates the current time in various formats.\"\"\"\n    self.datetime = dt.now(dt.now().astimezone().tzinfo)\n    self.iso = self.datetime.isoformat()\n    self.date = self.datetime.strftime(\"%Y-%m-%d\")\n    self.time = self.datetime.strftime(\"%H:%M:%S\")\n    self.filestamp = self.datetime.strftime(\"%Y-%m-%dT%H-%M-%S\")\n    self.timezone = self.datetime.strftime(\"%Z\")\n    self.utc_offset = self.datetime.strftime(\"%z\")\n</code></pre>"},{"location":"graphs/","title":"graphs","text":"<p>This module contains the functions used to create graphs that coordinate multi-agent workflows</p> <p>Functions:</p> Name Description <code>compile_workflow</code> <p>Compiles the workflow from the given state graph.</p> <code>create_team_graph</code> <p>Creates a state graph for a given team.</p> <code>run_team_workflow</code> <p>Runs the team workflow for a given project type and goal.</p>"},{"location":"graphs/#libs.graphs.compile_workflow","title":"libs.graphs.compile_workflow","text":"<pre><code>compile_workflow(graph)\n</code></pre> <p>Compiles the workflow from the given state graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>StateGraph</code> <p>The state graph to compile.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The compiled workflow.</p> Source code in <code>libs\\graphs.py</code> <pre><code>def compile_workflow(graph: StateGraph) -&gt; dict:\n    \"\"\"Compiles the workflow from the given state graph.\n\n    Args:\n        graph (StateGraph): The state graph to compile.\n\n    Returns:\n        dict: The compiled workflow.\n    \"\"\"\n    workflow = graph.compile()\n    return workflow\n</code></pre>"},{"location":"graphs/#libs.graphs.create_team_graph","title":"libs.graphs.create_team_graph","text":"<pre><code>create_team_graph(team)\n</code></pre> <p>Creates a state graph for a given team.</p> <p>Parameters:</p> Name Type Description Default <code>team</code> <code>Team</code> <p>The team for which the state graph is created.</p> required <p>Returns:</p> Name Type Description <code>StateGraph</code> <code>StateGraph</code> <p>The state graph representing the team's workflow.</p> Source code in <code>libs\\graphs.py</code> <pre><code>def create_team_graph(team: Team) -&gt; StateGraph:\n    \"\"\"Creates a state graph for a given team.\n\n    Args:\n        team (Team): The team for which the state graph is created.\n\n    Returns:\n        StateGraph: The state graph representing the team's workflow.\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\")\n\n        team_graph = StateGraph(team)\n\n        # Add entry and exit nodes\n        team_graph.set_entry_point(team.config.graph_config[\"entry\"])\n        if AGENTS[team.config.graph_config[\"finish\"]][\"needs_review\"]:\n            team_graph.set_finish_point(f\"{team.config.graph_config['finish']}_reviewer\")\n        else:\n            team_graph.set_finish_point(team.config.graph_config[\"finish\"])\n\n        # Add each agent on the team as a node\n        for member in team.members:\n            team_graph.add_node(\n                member.name,\n                member.invoke,\n            )\n\n        # Get pre-defined workflow order from config\n        edge_order = team.config.graph_config[\"edge_order\"]\n\n        for edge_idx, member_name in enumerate(edge_order):\n            if edge_idx &lt; len(edge_order) - 1:\n                next_member = edge_order[edge_idx + 1]\n            else:\n                next_member = END\n\n            # Define the runnable that is used to see if an agent is finished\n            @chain\n            def check_member_finished(member_name=member_name):\n                if member_name in team.members_finished:\n                    return str(True)\n                else:\n                    return str(False)\n\n            if AGENTS[member_name][\"needs_review\"]:\n                team_graph.add_conditional_edges(\n                    member_name,\n                    check_member_finished,\n                    {\"True\": next_member, \"False\": f\"{member_name}_reviewer\"},\n                )\n                if f\"{member_name}_reviewer\" != f'{team.config.graph_config[\"finish\"]}_reviewer':\n                    team_graph.add_edge(f\"{member_name}_reviewer\", next_member)\n                else:\n                    pass\n            else:\n                team_graph.add_edge(member_name, next_member)\n\n    return team_graph\n</code></pre>"},{"location":"graphs/#libs.graphs.run_team_workflow","title":"libs.graphs.run_team_workflow","text":"<pre><code>run_team_workflow(\n    project_type=\"small\",\n    project_goal=\"Tell a funny dad joke\",\n    **kwargs\n)\n</code></pre> <p>Runs the team workflow for a given project type and goal.</p> <p>Parameters:</p> Name Type Description Default <code>project_type</code> <code>str</code> <p>The type of the project. Defaults to \"small\".</p> <code>'small'</code> <code>project_goal</code> <code>str</code> <p>The goal of the project. Defaults to \"Tell a funny dad joke\".</p> <code>'Tell a funny dad joke'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Team</code> <code>Team</code> <p>The team after running the workflow.</p> Source code in <code>libs\\graphs.py</code> <pre><code>def run_team_workflow(\n    project_type: str = \"small\", project_goal: str = \"Tell a funny dad joke\", **kwargs\n) -&gt; Team:\n    \"\"\"Runs the team workflow for a given project type and goal.\n\n    Args:\n        project_type (str, optional): The type of the project. Defaults to \"small\".\n        project_goal (str, optional): The goal of the project. Defaults to \"Tell a funny dad joke\".\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Team: The team after running the workflow.\n    \"\"\"\n    project = Project(project_type, goal=project_goal)\n\n    # TODO: implement project-level workflows with multiple teams\n\n    # This selects the first team from a list of teams\n    team = project.teams[0]\n    team.goal = project_goal\n    team_graph = create_team_graph(team)\n    team_workflow = team_graph.compile()\n\n    member_names = team.fetch_member_names()\n    color_map = map_member_colors(member_names, color_names)\n\n    prior_submissions = []\n    for s in team_workflow.stream(team):\n        if \"__end__\" not in s:\n            for agent in team.fetch_member_names():\n                try:\n                    if \"Hello! I'm on team\" not in team.outputs.last[agent][\"message\"]:\n                        if team.outputs.last[agent][\"message\"] not in prior_submissions:\n                            print_heading(colored(agent, color=color_map[agent]))\n                            try:\n                                print_dict(\n                                    team.outputs.last[agent][\"message\"],\n                                    color=color_map[agent],\n                                )\n                            except:\n                                print(\n                                    colored(\n                                        team.outputs.last[agent][\"message\"],\n                                        color=color_map[agent],\n                                    )\n                                )\n                            prior_submissions.append(team.outputs.last[agent][\"message\"])\n\n                except Exception as e:\n                    print(\n                        \"---------------------------------------------------------------------------------\\n\"\n                    )\n                    print(colored(f\"An Exception occurred: {e}\", \"red\", attrs=[\"bold\"]))\n                    print(\n                        \"---------------------------------------------------------------------------------\\n\"\n                    )\n\n    return team\n</code></pre>"},{"location":"io/","title":"io","text":"<p>Classes:</p> Name Description <code>File</code> <p>Class for file configuration.</p> <code>IO</code> <p>Base class for file I/O operations.</p> <code>IOtext</code> <p>I/O class for handling text files.</p> <p>Functions:</p> Name Description <code>read_csv</code> <p>Reads a CSV file and returns its contents as a DataFrame.</p> <code>read_database</code> <p>Attempts to connect to an SQLite database and returns the connection.</p> <code>read_file</code> <p>Reads a file based on its extension and returns its contents.</p> <code>read_joblib</code> <p>Reads a text file and returns its contents as a string.</p> <code>read_json</code> <p>Reads a JSON file and returns its contents as a dictionary.</p> <code>read_parquet</code> <p>Reads a Parquet file and returns its contents as a DataFrame.</p> <code>read_xlsx</code> <p>Reads an Excel (XLSX) file and returns its contents as a DataFrame.</p> <code>write_csv</code> <p>Writes the given DataFrame to a CSV file.</p> <code>write_file</code> <p>Writes content to a file based on its extension.</p> <code>write_joblib</code> <p>Reads a text file and returns its contents as a string.</p> <code>write_json</code> <p>Writes the given dictionary to a JSON file.</p> <code>write_parquet</code> <p>Writes the given DataFrame or PyArrow Table to a Parquet file.</p>"},{"location":"io/#libs.utilities.io.File","title":"libs.utilities.io.File","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class for file configuration.</p> <p>This class uses helper functions to initialize attributes like path, name, type, and existence. It also creates an appropriate I/O handler based on the file type (currently only text files are supported).</p> <p>Methods:</p> Name Description <code>read</code> <p>Reads the file content using the I/O handler.</p> <code>write</code> <p>Writes data to the file using the I/O handler.</p>"},{"location":"io/#libs.utilities.io.File.read","title":"libs.utilities.io.File.read","text":"<pre><code>read()\n</code></pre> <p>Reads the file content using the I/O handler.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The content read from the file.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read(self) -&gt; Any:\n    \"\"\"\n    Reads the file content using the I/O handler.\n\n    Returns:\n        The content read from the file.\n    \"\"\"\n    if self.io:\n        self.content = self.io.read()\n</code></pre>"},{"location":"io/#libs.utilities.io.File.write","title":"libs.utilities.io.File.write","text":"<pre><code>write(content)\n</code></pre> <p>Writes data to the file using the I/O handler.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Any</code> <p>The data to write to the file.</p> required Source code in <code>libs\\utilities\\io.py</code> <pre><code>def write(self, content: Any) -&gt; None:\n    \"\"\"\n    Writes data to the file using the I/O handler.\n\n    Args:\n        content: The data to write to the file.\n    \"\"\"\n    if self.io:\n        self.io.write(content=content)\n        self.content = content\n</code></pre>"},{"location":"io/#libs.utilities.io.IO","title":"libs.utilities.io.IO","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for file I/O operations.</p> <p>This class defines the basic structure and interface for file readers and writers. Specific file types should subclass IO and implement the read and write methods.</p> <p>Methods:</p> Name Description <code>read</code> <p>Read the file content.</p> <code>write</code> <p>Write data to the file.</p>"},{"location":"io/#libs.utilities.io.IO.read","title":"libs.utilities.io.IO.read","text":"<pre><code>read(filepath=None, **kwargs)\n</code></pre> <p>Read the file content.</p> <p>This method is expected to be overridden by subclasses.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read(self, filepath: Optional[str] = None, **kwargs) -&gt; Any:\n    \"\"\"\n    Read the file content.\n\n    This method is expected to be overridden by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The read method must be implemented in the subclass.\")\n</code></pre>"},{"location":"io/#libs.utilities.io.IO.write","title":"libs.utilities.io.IO.write","text":"<pre><code>write(filepath=None, data=None, **kwargs)\n</code></pre> <p>Write data to the file.</p> <p>This method is expected to be overridden by subclasses.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def write(self, filepath: Optional[str] = None, data: Any = None, **kwargs) -&gt; None:\n    \"\"\"\n    Write data to the file.\n\n    This method is expected to be overridden by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The write method must be implemented in the subclass.\")\n</code></pre>"},{"location":"io/#libs.utilities.io.IOtext","title":"libs.utilities.io.IOtext","text":"<p>               Bases: <code>IO</code></p> <p>I/O class for handling text files.</p> <p>Inherits from IO and implements the read and write methods using standard Python I/O.</p> <p>Methods:</p> Name Description <code>read</code> <p>Reads a text file and returns its contents as a string.</p> <code>write</code> <p>Writes a string to a text file.</p>"},{"location":"io/#libs.utilities.io.IOtext.read","title":"libs.utilities.io.IOtext.read","text":"<pre><code>read(filepath=None, **kwargs)\n</code></pre> <p>Reads a text file and returns its contents as a string.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the text file. If not provided,                       the instance's <code>path</code> attribute is used.</p> <code>None</code> <code>encoding</code> <code>str</code> <p>The file encoding (default is \"utf-8\").</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The contents of the file, or None if reading fails.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read(self, filepath: Optional[str] = None, **kwargs) -&gt; Optional[str]:\n    \"\"\"\n    Reads a text file and returns its contents as a string.\n\n    Args:\n        filepath (str, optional): The path to the text file. If not provided,\n                                  the instance's `path` attribute is used.\n        encoding (str): The file encoding (default is \"utf-8\").\n\n    Returns:\n        Optional[str]: The contents of the file, or None if reading fails.\n    \"\"\"\n    action = \"READ\"\n    target_path = filepath or self.path\n    encoding = kwargs.get(\"encoding\", \"utf-8\")\n    try:\n        with open(target_path, \"r\", encoding=encoding) as file_in:\n            content = file_in.read()\n        _print_io_status(target_path, action, \"SUCCESS\")\n        return content\n    except Exception as e:\n        _print_io_status(target_path, action, \"FAIL\", error=e)\n        return None\n</code></pre>"},{"location":"io/#libs.utilities.io.IOtext.write","title":"libs.utilities.io.IOtext.write","text":"<pre><code>write(filepath=None, data='', **kwargs)\n</code></pre> <p>Writes a string to a text file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the text file. If not provided,                       the instance's <code>path</code> attribute is used.</p> <code>None</code> <code>data</code> <code>str</code> <p>The text content to write.</p> <code>''</code> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def write(self, filepath: Optional[str] = None, data: str = \"\", **kwargs) -&gt; None:\n    \"\"\"\n    Writes a string to a text file.\n\n    Args:\n        filepath (str, optional): The path to the text file. If not provided,\n                                  the instance's `path` attribute is used.\n        data (str): The text content to write.\n    \"\"\"\n    action = \"WRITE\"\n    target_path = filepath or self.path\n    if _check_exists(target_path):\n        action = \"OVERWRITE\"\n    try:\n        with open(target_path, \"w+\", encoding=\"utf-8\") as outfile:\n            outfile.write(data)\n        _print_io_status(target_path, action, \"SUCCESS\")\n    except Exception as e:\n        _print_io_status(target_path, action, \"FAIL\", error=e)\n</code></pre>"},{"location":"io/#libs.utilities.io._check_exists","title":"libs.utilities.io._check_exists","text":"<pre><code>_check_exists(*args, **kwargs)\n</code></pre> <p>Check if a file exists at the specified filepath.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the file exists, otherwise False.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def _check_exists(*args, **kwargs) -&gt; bool:\n    \"\"\"\n    Check if a file exists at the specified filepath.\n\n    Args:\n        path (str): The path to the file.\n\n    Returns:\n        bool: True if the file exists, otherwise False.\n    \"\"\"\n    if kwargs:\n        return os.path.exists(kwargs.get(\"path\"))\n    elif args:    \n        return os.path.exists(args[0])\n    else:\n        return False\n</code></pre>"},{"location":"io/#libs.utilities.io._get_abspath","title":"libs.utilities.io._get_abspath","text":"<pre><code>_get_abspath(*args, **kwargs)\n</code></pre> <p>Return the absolute path based on a provided 'path' keyword argument.</p> Example <p>_get_abspath(path=\"relative/path.txt\")</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def _get_abspath(*args, **kwargs) -&gt; str:\n    \"\"\"\n    Return the absolute path based on a provided 'path' keyword argument.\n\n    Example:\n        _get_abspath(path=\"relative/path.txt\")\n    \"\"\"\n    if kwargs:\n        return os.path.abspath(kwargs.get(\"path\"))\n    elif args:\n        return os.path.abspath(args[0])   \n</code></pre>"},{"location":"io/#libs.utilities.io._get_basename","title":"libs.utilities.io._get_basename","text":"<pre><code>_get_basename(*args, **kwargs)\n</code></pre> <p>Return the base name (the final component) of the given 'path'.</p> Example <p>_get_basename(path=\"/full/path/to/file.txt\")</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def _get_basename(*args, **kwargs) -&gt; str:\n    \"\"\"\n    Return the base name (the final component) of the given 'path'.\n\n    Example:\n        _get_basename(path=\"/full/path/to/file.txt\")\n    \"\"\"\n    if kwargs:\n        return os.path.basename(kwargs.get(\"path\"))\n    elif args:\n        return os.path.basename(args[0])\n</code></pre>"},{"location":"io/#libs.utilities.io._get_class","title":"libs.utilities.io._get_class","text":"<pre><code>_get_class(class_name=None)\n</code></pre> <p>Return the class object given its name as a string.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def _get_class(class_name: str = None):\n    \"\"\"Return the class object given its name as a string.\"\"\"\n    return globals()[class_name]\n</code></pre>"},{"location":"io/#libs.utilities.io._get_filetype","title":"libs.utilities.io._get_filetype","text":"<pre><code>_get_filetype(*args, **kwargs)\n</code></pre> <p>Return the file type (file extension) from the provided 'path'.</p> Example <p>_get_type(path=\"/full/path/to/file.txt\")  -&gt; \"txt\"</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def _get_filetype(*args, **kwargs) -&gt; str:\n    \"\"\"\n    Return the file type (file extension) from the provided 'path'.\n\n    Example:\n        _get_type(path=\"/full/path/to/file.txt\")  -&gt; \"txt\"\n    \"\"\"\n    if kwargs:\n        path = kwargs.get(\"path\")\n    elif args: \n        path = args[0]    \n    return os.path.basename(path).split(\".\")[-1] if \".\" in path else \"\"\n</code></pre>"},{"location":"io/#libs.utilities.io._get_io","title":"libs.utilities.io._get_io","text":"<pre><code>_get_io(self)\n</code></pre> <p>Factory method to return an instance of the appropriate I/O subclass based on the file type.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def _get_io(self) -&gt; IO:\n    \"\"\"\n    Factory method to return an instance of the appropriate I/O subclass\n    based on the file type.\n    \"\"\"\n    io_map: Dict[str, Callable[..., IO]] = {\n        \"txt\": IOtext,\n        # \"json\": IOjson,     # You can add additional mappings here.\n        # \"csv\": IOcsv,\n        # \"sqlite\": IOsqlite,\n        # \"joblib\": IOjoblib,\n        # \"parquet\": IOparquet,\n    }\n    # Choose the I/O class based on file extension, defaulting to IOtext if not found.\n    io_class = io_map.get(self.filetype.lower(), IOtext)\n    return io_class(path=self.path)\n</code></pre>"},{"location":"io/#libs.utilities.io._get_name","title":"libs.utilities.io._get_name","text":"<pre><code>_get_name(variable=None)\n</code></pre> <p>Return the name attribute of a variable, if available.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def _get_name(variable: object = None) -&gt; str:\n    \"\"\"Return the name attribute of a variable, if available.\"\"\"\n    return getattr(variable, \"name\", \"Unknown\")\n</code></pre>"},{"location":"io/#libs.utilities.io._print_io_status","title":"libs.utilities.io._print_io_status","text":"<pre><code>_print_io_status(filepath, action, status, **kwargs)\n</code></pre> <p>Print the status of an I/O operation.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The file path.</p> required <code>action</code> <code>str</code> <p>The action performed (e.g., READ, WRITE).</p> required <code>status</code> <code>str</code> <p>The status of the action (e.g., SUCCESS, FAIL).</p> required <code>error</code> <code>Exception</code> <p>The error encountered (if any).</p> required Source code in <code>libs\\utilities\\io.py</code> <pre><code>def _print_io_status(filepath: str, action: str, status: str, **kwargs) -&gt; None:\n    \"\"\"\n    Print the status of an I/O operation.\n\n    Args:\n        filepath (str): The file path.\n        action (str): The action performed (e.g., READ, WRITE).\n        status (str): The status of the action (e.g., SUCCESS, FAIL).\n        error (Exception, optional): The error encountered (if any).\n    \"\"\"\n    error = kwargs.get(\"error\", None)\n    if error:\n        print(f\"{action} {status}:\\n{filepath}\\nError: {error}\")\n    else:\n        print(f\"{action} {status}:\\n{filepath}\")\n</code></pre>"},{"location":"io/#libs.utilities.io.read_csv","title":"libs.utilities.io.read_csv","text":"<pre><code>read_csv(filepath)\n</code></pre> <p>Reads a CSV file and returns its contents as a DataFrame.</p> <p>This function attempts to read a CSV file from the specified filepath. If successful, it logs a \"SUCCESS\" status and returns the contents of the file as a DataFrame. If an error occurs, it logs a \"FAIL\" status.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the CSV file to be read.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>pd.DataFrame: The contents of the CSV file if read successfully,</p> <code>DataFrame | None</code> <p>otherwise None.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If any error occurs during reading the CSV file.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read_csv(filepath: str) -&gt; pd.DataFrame | None:\n    \"\"\"Reads a CSV file and returns its contents as a DataFrame.\n\n    This function attempts to read a CSV file from the specified filepath. If\n    successful, it logs a \"SUCCESS\" status and returns the contents of the file\n    as a DataFrame. If an error occurs, it logs a \"FAIL\" status.\n\n    Args:\n        filepath (str): The path to the CSV file to be read.\n\n    Returns:\n        pd.DataFrame: The contents of the CSV file if read successfully,\n        otherwise None.\n\n    Raises:\n        Exception: If any error occurs during reading the CSV file.\n    \"\"\"\n    action = \"READ\"\n    try:\n        contents = pd.read_csv(filepath)\n        _print_io_status(filepath, action, status=\"SUCCESS\")\n        return contents\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n        return None\n</code></pre>"},{"location":"io/#libs.utilities.io.read_database","title":"libs.utilities.io.read_database","text":"<pre><code>read_database(filepath)\n</code></pre> <p>Attempts to connect to an SQLite database and returns the connection.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the SQLite database file.</p> required <p>Returns:</p> Type Description <code>Connection | None</code> <p>sqlite3.Connection or None: The SQLite database connection if successful, otherwise None.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read_database(filepath: str) -&gt; sqlite3.Connection | None:\n    \"\"\"Attempts to connect to an SQLite database and returns the connection.\n\n    Args:\n        filepath (str): The path to the SQLite database file.\n\n    Returns:\n        sqlite3.Connection or None: The SQLite database connection if successful, otherwise None.\n    \"\"\"\n    database = None\n    if \".sqlite\" in os.path.basename(filepath):\n        try:\n            database = sqlite3.connect(filepath)\n            print(\"Connection to SQLite DB SUCCESS\")\n        except sqlite3.Error as e:\n            print(\"Connection to SQLite DB FAILED\")\n            print(f\"The error '{e}' occurred\")\n    return database\n</code></pre>"},{"location":"io/#libs.utilities.io.read_file","title":"libs.utilities.io.read_file","text":"<pre><code>read_file(filepath)\n</code></pre> <p>Reads a file based on its extension and returns its contents.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the file to be read.</p> required <p>Returns:</p> Type Description <code>object | None</code> <p>The contents of the file read based on its extension.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read_file(filepath: str) -&gt; object | None:\n    \"\"\"Reads a file based on its extension and returns its contents.\n\n    Args:\n        filepath (str): The path to the file to be read.\n\n    Returns:\n        The contents of the file read based on its extension.\n    \"\"\"\n    filetype = os.path.basename(filepath).split(\".\")[-1]\n    if filetype == \"csv\":\n        content = read_csv(filepath)\n    elif filetype == \"xlsx\":\n        content = read_xlsx(filepath)\n    elif filetype == \"parquet\":\n        content = read_parquet(filepath)\n    elif filetype == \"json\":\n        content = read_json(filepath)\n    elif filetype == \"joblib\":\n        content = read_joblib(filepath)\n    elif filetype == \"hdf5\":\n        content = read_hdf5(filepath)\n    elif filetype == \"py\":\n        content = read_text(filepath)\n    else:\n        content = read_text(filepath)\n    return content\n</code></pre>"},{"location":"io/#libs.utilities.io.read_joblib","title":"libs.utilities.io.read_joblib","text":"<pre><code>read_joblib(filepath)\n</code></pre> <p>Reads a text file and returns its contents as a string.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the text file to be read.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The contents of the text file if read successfully,</p> <code>str | None</code> <p>otherwise None.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read_joblib(filepath: str) -&gt; str | None:\n    \"\"\"Reads a text file and returns its contents as a string.\n\n    Args:\n        filepath (str): The path to the text file to be read.\n\n    Returns:\n        str: The contents of the text file if read successfully,\n        otherwise None.\n    \"\"\"\n    action = \"READ\"\n    try:\n        with open(filepath, \"rb\") as file_in:\n            content = joblib.load(file_in)\n        _print_io_status(filepath, action, status=\"SUCCESS\")\n        return content\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n        return None\n</code></pre>"},{"location":"io/#libs.utilities.io.read_json","title":"libs.utilities.io.read_json","text":"<pre><code>read_json(filepath)\n</code></pre> <p>Reads a JSON file and returns its contents as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the JSON file to be read.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>The contents of the JSON file if read successfully,</p> <code>dict | None</code> <p>otherwise None.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read_json(filepath: str) -&gt; dict | None:\n    \"\"\"Reads a JSON file and returns its contents as a dictionary.\n\n    Args:\n        filepath (str): The path to the JSON file to be read.\n\n    Returns:\n        dict: The contents of the JSON file if read successfully,\n        otherwise None.\n    \"\"\"\n    action = \"READ\"\n    try:\n        with open(filepath, \"r\", encoding=\"utf-8\") as file_in:\n            content = json.load(file_in)\n            _print_io_status(filepath, action, status=\"SUCCESS\")\n        return content\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n        return None\n</code></pre>"},{"location":"io/#libs.utilities.io.read_parquet","title":"libs.utilities.io.read_parquet","text":"<pre><code>read_parquet(filepath)\n</code></pre> <p>Reads a Parquet file and returns its contents as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the Parquet file to be read.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>pd.DataFrame: The contents of the Parquet file if read successfully,</p> <code>DataFrame | None</code> <p>otherwise None.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read_parquet(filepath: str) -&gt; pd.DataFrame | None:\n    \"\"\"Reads a Parquet file and returns its contents as a DataFrame.\n\n    Args:\n        filepath (str): The path to the Parquet file to be read.\n\n    Returns:\n        pd.DataFrame: The contents of the Parquet file if read successfully,\n        otherwise None.\n    \"\"\"\n    action = \"READ\"\n    try:\n        contents = pq.read_table(filepath).to_pandas()\n        _print_io_status(filepath, action, status=\"SUCCESS\")\n        return contents\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n        return None\n</code></pre>"},{"location":"io/#libs.utilities.io.read_xlsx","title":"libs.utilities.io.read_xlsx","text":"<pre><code>read_xlsx(filepath)\n</code></pre> <p>Reads an Excel (XLSX) file and returns its contents as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the XLSX file to be read.</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>pd.DataFrame: The contents of the XLSX file if read successfully,</p> <code>DataFrame | None</code> <p>otherwise None.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def read_xlsx(filepath: str) -&gt; pd.DataFrame | None:\n    \"\"\"Reads an Excel (XLSX) file and returns its contents as a DataFrame.\n\n    Args:\n        filepath (str): The path to the XLSX file to be read.\n\n    Returns:\n        pd.DataFrame: The contents of the XLSX file if read successfully,\n        otherwise None.\n    \"\"\"\n    action = \"READ\"\n    try:\n        contents = pd.read_excel(filepath)\n        _print_io_status(filepath, action, status=\"SUCCESS\")\n        return contents\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n        return None\n</code></pre>"},{"location":"io/#libs.utilities.io.write_csv","title":"libs.utilities.io.write_csv","text":"<pre><code>write_csv(content, filepath)\n</code></pre> <p>Writes the given DataFrame to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>DataFrame</code> <p>The DataFrame to write to the CSV file.</p> required <code>filepath</code> <code>str</code> <p>The path to the CSV file to be written.</p> required Source code in <code>libs\\utilities\\io.py</code> <pre><code>def write_csv(content: pd.DataFrame, filepath: str) -&gt; None:\n    \"\"\"Writes the given DataFrame to a CSV file.\n\n    Args:\n        content (pd.DataFrame): The DataFrame to write to the CSV file.\n        filepath (str): The path to the CSV file to be written.\n    \"\"\"\n    action = \"WRITE\"\n    if _check_exists(filepath):\n        action = \"OVERWRITE\"\n    try:\n        content.to_csv(filepath, header=True, index=False)\n        _print_io_status(filepath, action, status=\"SUCCESS\")\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n</code></pre>"},{"location":"io/#libs.utilities.io.write_file","title":"libs.utilities.io.write_file","text":"<pre><code>write_file(content, filepath)\n</code></pre> <p>Writes content to a file based on its extension.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>object</code> <p>The content to write to the file.</p> required <code>filepath</code> <code>str</code> <p>The path to the file to be written.</p> required Source code in <code>libs\\utilities\\io.py</code> <pre><code>def write_file(content: object, filepath: str) -&gt; None:\n    \"\"\"Writes content to a file based on its extension.\n\n    Args:\n        content: The content to write to the file.\n        filepath (str): The path to the file to be written.\n    \"\"\"\n    filetype = os.path.basename(filepath).split(\".\")[-1]\n    if filetype == \"csv\":\n        write_csv(content, filepath)\n    elif filetype == \"parquet\":\n        write_parquet(content, filepath)\n    elif filetype == \"json\":\n        write_json(content, filepath)\n    elif filetype == \"joblib\":\n        write_joblib(content, filepath)\n    elif filetype == \"hdf5\":\n        write_hdf5(content, filepath)\n    else:\n        write_text(content, filepath)\n</code></pre>"},{"location":"io/#libs.utilities.io.write_joblib","title":"libs.utilities.io.write_joblib","text":"<pre><code>write_joblib(content, filepath)\n</code></pre> <p>Reads a text file and returns its contents as a string.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the text file to be read.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The contents of the text file if read successfully,</p> <code>str | None</code> <p>otherwise None.</p> Source code in <code>libs\\utilities\\io.py</code> <pre><code>def write_joblib(content: dict, filepath: str) -&gt; str | None:\n    \"\"\"Reads a text file and returns its contents as a string.\n\n    Args:\n        filepath (str): The path to the text file to be read.\n\n    Returns:\n        str: The contents of the text file if read successfully,\n        otherwise None.\n    \"\"\"\n    action = \"WRITE\"\n    if _check_exists(filepath):\n        action = \"OVERWRITE\"\n    try:\n        with open(filepath, \"wb\") as outfile:\n            joblib.dump(content, outfile)\n        _print_io_status(filepath, action, status=\"SUCCESS\")\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n</code></pre>"},{"location":"io/#libs.utilities.io.write_json","title":"libs.utilities.io.write_json","text":"<pre><code>write_json(content, filepath)\n</code></pre> <p>Writes the given dictionary to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>dict</code> <p>The content to write to the JSON file.</p> required <code>filepath</code> <code>str</code> <p>The path to the JSON file to be written.</p> required Source code in <code>libs\\utilities\\io.py</code> <pre><code>def write_json(content: dict, filepath: str) -&gt; None:\n    \"\"\"Writes the given dictionary to a JSON file.\n\n    Args:\n        content (dict): The content to write to the JSON file.\n        filepath (str): The path to the JSON file to be written.\n    \"\"\"\n    action = \"WRITE\"\n    if _check_exists(filepath):\n        action = \"OVERWRITE\"\n    try:\n        if (isinstance(content, dict)) and (\".json\" in os.path.basename(filepath)):\n            content = json.dumps(content)\n        with open(filepath, \"w+\", encoding=\"utf-8\") as outfile:\n            json.dump(content, outfile, indent=4)\n        _print_io_status(filepath, action, status=\"SUCCESS\")\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n</code></pre>"},{"location":"io/#libs.utilities.io.write_parquet","title":"libs.utilities.io.write_parquet","text":"<pre><code>write_parquet(content, filepath)\n</code></pre> <p>Writes the given DataFrame or PyArrow Table to a Parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>DataFrame or Table</code> <p>The content to write to the Parquet file.</p> required <code>filepath</code> <code>str</code> <p>The path to the Parquet file to be written.</p> required Source code in <code>libs\\utilities\\io.py</code> <pre><code>def write_parquet(content: pd.DataFrame | pa.Table, filepath: str) -&gt; None:\n    \"\"\"Writes the given DataFrame or PyArrow Table to a Parquet file.\n\n    Args:\n        content (pd.DataFrame or pa.Table): The content to write to the Parquet file.\n        filepath (str): The path to the Parquet file to be written.\n    \"\"\"\n    action = \"WRITE\"\n    if _check_exists(filepath):\n        action = \"OVERWRITE\"\n    try:\n        if isinstance(content, pd.DataFrame):\n            df_pa = pa.Table.from_pandas(content)\n            pq.write_table(df_pa, filepath)\n        elif isinstance(content, pa.Table):\n            pq.write_table(content, filepath)\n        _print_io_status(filepath, action, status=\"SUCCESS\")\n    except Exception as e:\n        _print_io_status(filepath, action, status=\"FAIL\", error=e)\n</code></pre>"},{"location":"models/","title":"models","text":"<p>This module contains the Model class, used to define the model endpoints that are assigned to agents.</p> <p>Classes:</p> Name Description <code>Model</code> <p>Class for LLM and Embedder clients</p> <code>ModelConfig</code> <p>Class for model configuration</p>"},{"location":"models/#libs.models.Model","title":"libs.models.Model","text":"<pre><code>Model(model_config=ModelConfig())\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Class for LLM and Embedder clients</p> Source code in <code>libs\\models.py</code> <pre><code>def __init__(self, model_config: ModelConfig = ModelConfig()):\n    self.config = model_config\n    self.name = MODELS[self.api][self.type][self.size]\n    self.client = BaseLanguageModel\n</code></pre>"},{"location":"models/#libs.models.ModelConfig","title":"libs.models.ModelConfig","text":"<pre><code>ModelConfig(**kwargs)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Class for model configuration</p> Source code in <code>libs\\models.py</code> <pre><code>def __init__(self, **kwargs): \n    self.type = kwargs.get(\"type\", \"llm\")\n    self.size = kwargs.get(\"size\", DEFAULT_MODELS[\"llm\"][\"size\"])\n    self.api = kwargs.get(\"size\", DEFAULT_MODELS[\"llm\"][\"api\"])\n    self.api_key = APIS[self.api][\"key\"].get_secret_value()\n</code></pre>"},{"location":"printing/","title":"printing","text":"<p>Functions:</p> Name Description <code>eprint</code> <p>Pretty print a given object with no sorting,</p> <code>map_member_colors</code> <p>Map member names to colors.</p> <code>print_dict</code> <p>Print a dictionary with colored keys and values.</p> <code>print_heading</code> <p>Print a heading with a title enclosed in dashes.</p>"},{"location":"printing/#libs.utilities.printing.eprint","title":"libs.utilities.printing.eprint","text":"<pre><code>eprint(printable, color=['blue', 'green'], width=80)\n</code></pre> <p>Pretty print a given object with no sorting,</p> <p>Parameters:</p> Name Type Description Default <code>printable</code> <code>object</code> <p>The object to be pretty printed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>libs\\utilities\\printing.py</code> <pre><code>def eprint(printable: object, color: list[Color] | Color = [\"blue\", \"green\"], width=80) -&gt; None:\n    \"\"\"Pretty print a given object with no sorting,\n\n    Args:\n        printable (object): The object to be pretty printed.\n\n    Returns:\n        None\n    \"\"\"\n    if type(color) == str:\n        color = [color]\n    try:\n        display(print_md(printable))\n    except Exception:\n        try:\n            print_dict(printable, color)\n        except Exception:\n            print(\n                colored(\n                    pprint(printable, sort_dicts=False, width=width), color=color, force_color=True\n                )\n            )\n</code></pre>"},{"location":"printing/#libs.utilities.printing.map_member_colors","title":"libs.utilities.printing.map_member_colors","text":"<pre><code>map_member_colors(member_names, color_names)\n</code></pre> <p>Map member names to colors.</p> <p>Parameters:</p> Name Type Description Default <code>member_names</code> <code>list</code> <p>A list of member names.</p> required <code>color_names</code> <code>list</code> <p>A list of color names.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping member names to colors.</p> Source code in <code>libs\\utilities\\printing.py</code> <pre><code>def map_member_colors(member_names: list, color_names: list) -&gt; dict:\n    \"\"\"Map member names to colors.\n\n    Args:\n        member_names (list): A list of member names.\n        color_names (list): A list of color names.\n\n    Returns:\n        dict: A dictionary mapping member names to colors.\n    \"\"\"\n    member_colors = {}\n    for idx, member_name in enumerate(member_names):\n        member_colors[member_name] = color_names[idx]\n    return member_colors\n</code></pre>"},{"location":"printing/#libs.utilities.printing.print_dict","title":"libs.utilities.printing.print_dict","text":"<pre><code>print_dict(\n    dict2print, colors=[\"cyan\", \"light_blue\"], width=80\n)\n</code></pre> <p>Print a dictionary with colored keys and values.</p> <p>Parameters:</p> Name Type Description Default <code>dict2print</code> <code>dict</code> <p>The dictionary to be printed.</p> required <code>colors</code> <code>list</code> <p>The color of the keys and values. Defaults to [\"cyan\",\"light_blue\"].</p> <code>['cyan', 'light_blue']</code> <code>width</code> <code>(int, optional)</code> <p>The width of the output. Defaults to 80.</p> <code>80</code> <p>Returns:     None</p> Source code in <code>libs\\utilities\\printing.py</code> <pre><code>def print_dict(\n    dict2print: dict | str, colors: list[Color] | Color = [\"cyan\", \"light_blue\"], width: int = 80\n) -&gt; None:\n    \"\"\"Print a dictionary with colored keys and values.\n\n    Args:\n        dict2print (dict): The dictionary to be printed.\n        colors (list, optional): The color of the keys and values. Defaults to [\"cyan\",\"light_blue\"].\n        width (int,optional): The width of the output. Defaults to 80.\n    Returns:\n        None\n    \"\"\"\n    if isinstance(colors, str):\n        colors = [colors]\n    if isinstance(colors, list) and len(colors) == 1:\n        colors.append(colors[0])\n\n    try:\n        if not isinstance(dict2print, str):\n            if not ((hasattr(dict2print, \"items\")) and (callable(dict2print.items))):\n                dict2print = dict2print.__dict__\n            if isinstance(dict2print, dict):\n                for k, v in dict2print.items():\n                    k = k + \":\"\n                    printkey = colored(f\"{k:&lt;10}\", color=colors[0], attrs=[\"bold\"])\n                    printval = colored(f\"{v}\", color=colors[1])\n\n                    print(printkey, printval)\n    except:\n        pprint(dict2print, width=width)\n</code></pre>"},{"location":"printing/#libs.utilities.printing.print_heading","title":"libs.utilities.printing.print_heading","text":"<pre><code>print_heading(title_text, color='cyan')\n</code></pre> <p>Print a heading with a title enclosed in dashes.</p> <p>Parameters:</p> Name Type Description Default <code>title_text</code> <code>str</code> <p>The title text to be printed.</p> required <code>color</code> <code>str</code> <p>The color of the heading. Defaults to \"cyan\".</p> <code>'cyan'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>libs\\utilities\\printing.py</code> <pre><code>def print_heading(title_text: str, color: Color = \"cyan\") -&gt; None:\n    \"\"\"Print a heading with a title enclosed in dashes.\n\n    Args:\n        title_text (str): The title text to be printed.\n        color (str, optional): The color of the heading. Defaults to \"cyan\".\n\n    Returns:\n        None\n    \"\"\"\n    title_length = len(title_text)\n    title_bar = \"----\" + (\"-\" * title_length) + \"----\"\n    print(colored(title_bar, color, attrs=[\"bold\"], force_color=True))\n    print(colored(f\"    {title_text}\", color, attrs=[\"bold\"], force_color=True))\n    print(colored(title_bar, color, attrs=[\"bold\"], force_color=True))\n    return None\n</code></pre>"},{"location":"prompts/","title":"prompts","text":""},{"location":"prompts/#specifying-prompts-for-your-agents","title":"Specifying prompts for your agents","text":"<p>This documentation explains how to specify a reusable prompt using the dawgpyl library.</p> <p>To specify a prompt for your agents, follow these steps:</p> <ol> <li>Create a new prompt file or edit an existing one in your project directory.</li> <li>Define the prompt content within the file. This can include instructions, questions, or any text that you want the agent to use.</li> <li>Save the prompt file with a descriptive name that reflects its purpose.</li> <li>In your agent's configuration, reference the prompt file by its filepath to load and use the prompt.</li> </ol> <p>Example:</p> <pre><code>from dawgpyl import Agent\n\n# Load the prompt from a file\nwith open('path/to/your/prompt.txt', 'r') as file:\n    prompt_content = file.read()\n\n# Create an agent and set the prompt\nagent = Agent(prompt=prompt_content)\n\n# Use the agent with the specified prompt\nresponse = agent.respond(\"Your input here\")\nprint(response)\n</code></pre> <p>By following these steps, you can easily manage and reuse prompts across different agents in your project.</p> <p>dawgpyl makes it easy to specify reusable prompts for your agents. Simply create </p> <p>Simply create an entry into the <code>PROMPTS</code> dictionary in the configs/core.py file.</p> <pre><code>PROMPTS = {\n    \"default\": {\n        \"prompt_params\": [\n            \"self.inputs.last_message\",\n            \"self.task.objective\",\n            \"self.config.response_template\",\n        ],\n        \"prompt_system\": \"\"\"\n        You are a helpful assistant.\n        \"\"\",\n        \"prompt_template\": \"\"\"\n                Your task objective is: {self_task_objective}\\n\n\n                Your reviewer has provided the following feedback to help guide your next response: {self_inputs_last_message}\n\n                Your response must adhere to the following JSON format: {self_config_response_template}\\n\n            \"\"\",\n        \"response_template\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"response\": {\n                    \"type\": \"string\",\n                    \"description\": \"YOUR RESPONSE\",\n                },\n            },\n        },\n    },\n</code></pre>"},{"location":"teams/","title":"teams","text":"<p>This module contains the Team class, used to store the state of multi-agent workflows.</p> <p>Classes:</p> Name Description <code>Team</code> <p>Class for managing a team of agents.</p> <code>TeamConfig</code> <p>Class for storing agent configuration settings.</p> <p>Functions:</p> Name Description <code>compile_workflow</code> <p>Compiles the workflow from the given state graph.</p> <code>create_team_graph</code> <p>Creates a state graph for a given team.</p> <code>run_team_workflow</code> <p>Runs the team workflow for a given project type and goal.</p>"},{"location":"teams/#libs.teams.Team","title":"libs.teams.Team  <code>dataclass</code>","text":"<pre><code>Team(project, config_name='default')\n</code></pre> <p>Class for managing a team of agents. The name of the team determines the config that is retrieved</p> <p>Initializes the Team with the given project and configuration name.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>dict</code> <p>The project details.</p> required <code>config_name</code> <code>str</code> <p>The name of the team configuration. Defaults to \"default\".</p> <code>'default'</code> <p>Methods:</p> Name Description <code>__call__</code> <p>Calls the update method and returns the current team instance.</p> <code>add_member</code> <p>Adds a member to the team.</p> <code>add_reviewer</code> <p>Adds a reviewer to the team.</p> <code>assemble_team</code> <p>Assembles the team by adding members and reviewers if needed.</p> <code>check_finished</code> <p>Checks if a member has finished their task.</p> <code>fetch_member_names</code> <p>Fetches the names of all members in the team.</p> <code>fetch_updates</code> <p>Fetches updates from all team members.</p> <code>get_member_index</code> <p>Gets the index of a member in the team.</p> <code>push_reviews</code> <p>Pushes reviews from reviewers to the respective members.</p> <code>push_team_updates</code> <p>Pushes the current team instance to all members.</p> <code>request_introductions</code> <p>Requests introductions from all team members.</p> <code>return_self</code> <p>Returns the current instance of the team.</p> <code>update</code> <p>Updates the team by fetching updates, pushing reviews, and pushing team updates.</p> Source code in <code>libs\\teams.py</code> <pre><code>def __init__(self, project: dict, config_name: str = \"default\") -&gt; None:\n    \"\"\"\n    Initializes the Team with the given project and configuration name.\n\n    Args:\n        project (dict): The project details.\n        config_name (str): The name of the team configuration. Defaults to \"default\".\n    \"\"\"\n    self.name = generate_random_name()\n    self.config = TeamConfig(config_name)\n    self.project = project\n    self.leader = self.config.leader\n    self.members = []\n    self.members_finished = []\n    self.goal = None\n    self.backlog = {}\n    self.task_assignments = {}\n    self.inputs = TeamMessageLog()\n    self.outputs = TeamMessageLog()\n    self.final_answers = {}\n    self.event = Event(Target(get_class(self), self.name), \"created\")\n    self.log = Log()\n    self.log.add(self.event)\n    self.assemble_team()\n    self.update()\n</code></pre>"},{"location":"teams/#libs.teams.Team.__call__","title":"libs.teams.Team.__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Calls the update method and returns the current team instance.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the current team instance.</p> Source code in <code>libs\\teams.py</code> <pre><code>def __call__(self, *args, **kwargs) -&gt; dict:\n    \"\"\"\n    Calls the update method and returns the current team instance.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        dict: A dictionary containing the current team instance.\n    \"\"\"\n    for arg in args:\n        pass\n    for kwarg in kwargs:\n        pass\n    self.update()\n    return {\"team\": self.return_self()}\n</code></pre>"},{"location":"teams/#libs.teams.Team.add_member","title":"libs.teams.Team.add_member","text":"<pre><code>add_member(agent2add='default')\n</code></pre> <p>Adds a member to the team.</p> <p>Parameters:</p> Name Type Description Default <code>agent2add</code> <code>str</code> <p>The name of the agent to add. Defaults to \"default\".</p> <code>'default'</code> Source code in <code>libs\\teams.py</code> <pre><code>def add_member(self, agent2add: str = \"default\") -&gt; None:\n    \"\"\"\n    Adds a member to the team.\n\n    Args:\n        agent2add (str): The name of the agent to add. Defaults to \"default\".\n    \"\"\"\n    self.members.append(Agent(agent2add))\n    self.event = Event(Target(get_class(self), self.name), f\"added Agent('{agent2add}')\")\n    self.log.add(self.event)\n</code></pre>"},{"location":"teams/#libs.teams.Team.add_reviewer","title":"libs.teams.Team.add_reviewer","text":"<pre><code>add_reviewer(agent2review)\n</code></pre> <p>Adds a reviewer to the team.</p> <p>Parameters:</p> Name Type Description Default <code>agent2review</code> <code>str</code> <p>The name of the agent to review.</p> required Source code in <code>libs\\teams.py</code> <pre><code>def add_reviewer(self, agent2review: str) -&gt; None:\n    \"\"\"\n    Adds a reviewer to the team.\n\n    Args:\n        agent2review (str): The name of the agent to review.\n    \"\"\"\n    reviewer_name = f\"{agent2review}_reviewer\"\n    self.members.append(Agent(name=reviewer_name, agent_config=\"reviewer\"))\n    self.event = Event(Target(get_class(self), self.name), f\"added Agent('{reviewer_name}')\")\n    self.log.add(self.event)\n</code></pre>"},{"location":"teams/#libs.teams.Team.assemble_team","title":"libs.teams.Team.assemble_team","text":"<pre><code>assemble_team()\n</code></pre> <p>Assembles the team by adding members and reviewers if needed.</p> Source code in <code>libs\\teams.py</code> <pre><code>def assemble_team(self) -&gt; None:\n    \"\"\"\n    Assembles the team by adding members and reviewers if needed.\n    \"\"\"\n    for member in self.config.members:\n        self.add_member(member)\n        if self.members[-1].needs_review:\n            self.add_reviewer(agent2review=member)\n    self.event = Event(Target(get_class(self), self.name), \"assembled\")\n    self.log.add(self.event)\n</code></pre>"},{"location":"teams/#libs.teams.Team.check_finished","title":"libs.teams.Team.check_finished","text":"<pre><code>check_finished(member_name='')\n</code></pre> <p>Checks if a member has finished their task.</p> <p>Parameters:</p> Name Type Description Default <code>member_name</code> <code>str</code> <p>The name of the member.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"True\" if the member has finished, otherwise \"False\".</p> Source code in <code>libs\\teams.py</code> <pre><code>def check_finished(self, member_name: str = \"\") -&gt; str:\n    \"\"\"\n    Checks if a member has finished their task.\n\n    Args:\n        member_name (str): The name of the member.\n\n    Returns:\n        str: \"True\" if the member has finished, otherwise \"False\".\n    \"\"\"\n    member_index = self.get_member_index(member_name)\n    if self.members[member_index].finished:\n        return str(True)\n    else:\n        return str(False)\n</code></pre>"},{"location":"teams/#libs.teams.Team.fetch_member_names","title":"libs.teams.Team.fetch_member_names","text":"<pre><code>fetch_member_names()\n</code></pre> <p>Fetches the names of all members in the team.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of member names.</p> Source code in <code>libs\\teams.py</code> <pre><code>def fetch_member_names(self) -&gt; list:\n    \"\"\"\n    Fetches the names of all members in the team.\n\n    Returns:\n        list: A list of member names.\n    \"\"\"\n    member_names = [x.name for x in self.members]\n    return member_names\n</code></pre>"},{"location":"teams/#libs.teams.Team.fetch_updates","title":"libs.teams.Team.fetch_updates","text":"<pre><code>fetch_updates()\n</code></pre> <p>Fetches updates from all team members.</p> Source code in <code>libs\\teams.py</code> <pre><code>def fetch_updates(self) -&gt; None:\n    \"\"\"\n    Fetches updates from all team members.\n    \"\"\"\n    for member in self.members:\n        if len(member.inputs.history) &gt; 0:\n            self.inputs.history[member.name] = member.inputs.history\n        if len(member.inputs.last.keys()) &gt; 0:\n            self.inputs.last[member.name] = member.inputs.last\n        if len(member.outputs.history) &gt; 0:\n            self.outputs.history[member.name] = member.outputs.history\n        if len(member.outputs.last.keys()) &gt; 0:\n            self.outputs.last[member.name] = member.outputs.last\n        if member.final_answer and len(member.final_answer) &gt; 0:\n            self.final_answers[member.name] = member.final_answer\n</code></pre>"},{"location":"teams/#libs.teams.Team.get_member_index","title":"libs.teams.Team.get_member_index","text":"<pre><code>get_member_index(member_name='')\n</code></pre> <p>Gets the index of a member in the team.</p> <p>Parameters:</p> Name Type Description Default <code>member_name</code> <code>str</code> <p>The name of the member.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the member.</p> Source code in <code>libs\\teams.py</code> <pre><code>def get_member_index(self, member_name: str = \"\") -&gt; int:\n    \"\"\"\n    Gets the index of a member in the team.\n\n    Args:\n        member_name (str): The name of the member.\n\n    Returns:\n        int: The index of the member.\n    \"\"\"\n    member_order = self.fetch_member_names()\n    member_index = member_order.index(member_name)\n    return member_index\n</code></pre>"},{"location":"teams/#libs.teams.Team.push_reviews","title":"libs.teams.Team.push_reviews","text":"<pre><code>push_reviews()\n</code></pre> <p>Pushes reviews from reviewers to the respective members.</p> Source code in <code>libs\\teams.py</code> <pre><code>def push_reviews(self) -&gt; None:\n    \"\"\"\n    Pushes reviews from reviewers to the respective members.\n    \"\"\"\n    for member in self.members:\n        if self.outputs.last:\n            if self.outputs.last.get(f\"{member.name}_reviewer\", None):\n                reviewer_message = self.outputs.last.get(f\"{member.name}_reviewer\", None).get(\n                    \"message\", None\n                )\n                if \"Hello! I'm on team\" not in reviewer_message:\n                    member.inputs.add_message(reviewer_message)\n</code></pre>"},{"location":"teams/#libs.teams.Team.push_team_updates","title":"libs.teams.Team.push_team_updates","text":"<pre><code>push_team_updates()\n</code></pre> <p>Pushes the current team instance to all members.</p> Source code in <code>libs\\teams.py</code> <pre><code>def push_team_updates(self) -&gt; None:\n    \"\"\"\n    Pushes the current team instance to all members.\n    \"\"\"\n    for member in self.members:\n        member.team = self.return_self()\n</code></pre>"},{"location":"teams/#libs.teams.Team.request_introductions","title":"libs.teams.Team.request_introductions","text":"<pre><code>request_introductions()\n</code></pre> <p>Requests introductions from all team members.</p> Source code in <code>libs\\teams.py</code> <pre><code>def request_introductions(self) -&gt; None:\n    \"\"\"\n    Requests introductions from all team members.\n    \"\"\"\n    for member in self.members:\n        member.outputs.add_message(f\"Hello! My name is '{member.name}'\")\n        member.teammates = self.fetch_member_names()\n</code></pre>"},{"location":"teams/#libs.teams.Team.return_self","title":"libs.teams.Team.return_self","text":"<pre><code>return_self()\n</code></pre> <p>Returns the current instance of the team.</p> <p>Returns:</p> Name Type Description <code>Team</code> <code>Team</code> <p>The current instance of the team.</p> Source code in <code>libs\\teams.py</code> <pre><code>def return_self(self) -&gt; \"Team\":\n    \"\"\"\n    Returns the current instance of the team.\n\n    Returns:\n        Team: The current instance of the team.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"teams/#libs.teams.Team.update","title":"libs.teams.Team.update","text":"<pre><code>update()\n</code></pre> <p>Updates the team by fetching updates, pushing reviews, and pushing team updates.</p> Source code in <code>libs\\teams.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Updates the team by fetching updates, pushing reviews, and pushing team updates.\n    \"\"\"\n    self.fetch_updates()\n    self.push_reviews()\n    self.push_team_updates()\n</code></pre>"},{"location":"teams/#libs.teams.TeamConfig","title":"libs.teams.TeamConfig  <code>dataclass</code>","text":"<pre><code>TeamConfig(name='default')\n</code></pre> <p>Class for storing agent configuration settings.</p> <p>Initializes the TeamConfig with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the team configuration. Defaults to \"default\".</p> <code>'default'</code> Source code in <code>libs\\teams.py</code> <pre><code>def __init__(self, name: str = \"default\") -&gt; None:\n    \"\"\"\n    Initializes the TeamConfig with the given name.\n\n    Args:\n        name (str): The name of the team configuration. Defaults to \"default\".\n    \"\"\"\n    team_config = TEAMS[name]\n    self.name = name\n    self.leader = team_config[\"leader\"]\n    self.members = team_config[\"members\"]\n    self.graph_config = team_config[\"graph_config\"]\n</code></pre>"},{"location":"teams/#libs.teams.compile_workflow","title":"libs.teams.compile_workflow","text":"<pre><code>compile_workflow(graph)\n</code></pre> <p>Compiles the workflow from the given state graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>StateGraph</code> <p>The state graph to compile.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The compiled workflow.</p> Source code in <code>libs\\teams.py</code> <pre><code>def compile_workflow(graph: StateGraph) -&gt; dict:\n    \"\"\"Compiles the workflow from the given state graph.\n\n    Args:\n        graph (StateGraph): The state graph to compile.\n\n    Returns:\n        dict: The compiled workflow.\n    \"\"\"\n    workflow = graph.compile()\n    return workflow\n</code></pre>"},{"location":"teams/#libs.teams.create_team_graph","title":"libs.teams.create_team_graph","text":"<pre><code>create_team_graph(team)\n</code></pre> <p>Creates a state graph for a given team.</p> <p>Parameters:</p> Name Type Description Default <code>team</code> <code>Team</code> <p>The team for which the state graph is created.</p> required <p>Returns:</p> Name Type Description <code>StateGraph</code> <code>StateGraph</code> <p>The state graph representing the team's workflow.</p> Source code in <code>libs\\teams.py</code> <pre><code>def create_team_graph(team: Team) -&gt; StateGraph:\n    \"\"\"Creates a state graph for a given team.\n\n    Args:\n        team (Team): The team for which the state graph is created.\n\n    Returns:\n        StateGraph: The state graph representing the team's workflow.\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\")\n\n        team_graph = StateGraph(team)\n\n        # Add entry and exit nodes\n        team_graph.set_entry_point(team.config.graph_config[\"entry\"])\n        if AGENTS[team.config.graph_config[\"finish\"]][\"needs_review\"]:\n            team_graph.set_finish_point(f\"{team.config.graph_config['finish']}_reviewer\")\n        else:\n            team_graph.set_finish_point(team.config.graph_config[\"finish\"])\n\n        # Add each agent on the team as a node\n        for member in team.members:\n            team_graph.add_node(\n                member.name,\n                member.invoke,\n            )\n\n        # Get pre-defined workflow order from config\n        edge_order = team.config.graph_config[\"edge_order\"]\n\n        for edge_idx, member_name in enumerate(edge_order):\n            if edge_idx &lt; len(edge_order) - 1:\n                next_member = edge_order[edge_idx + 1]\n            else:\n                next_member = END\n\n            # Define the runnable that is used to see if an agent is finished\n            @chain\n            def check_member_finished(member_name=member_name):\n                if member_name in team.members_finished:\n                    return str(True)\n                else:\n                    return str(False)\n\n            if AGENTS[member_name][\"needs_review\"]:\n                team_graph.add_conditional_edges(\n                    member_name,\n                    check_member_finished,\n                    {\"True\": next_member, \"False\": f\"{member_name}_reviewer\"},\n                )\n                if f\"{member_name}_reviewer\" != f'{team.config.graph_config[\"finish\"]}_reviewer':\n                    team_graph.add_edge(f\"{member_name}_reviewer\", next_member)\n                else:\n                    pass\n            else:\n                team_graph.add_edge(member_name, next_member)\n\n    return team_graph\n</code></pre>"},{"location":"teams/#libs.teams.run_team_workflow","title":"libs.teams.run_team_workflow","text":"<pre><code>run_team_workflow(\n    project_type=\"small\",\n    project_goal=\"Tell a funny dad joke\",\n    **kwargs\n)\n</code></pre> <p>Runs the team workflow for a given project type and goal.</p> <p>Parameters:</p> Name Type Description Default <code>project_type</code> <code>str</code> <p>The type of the project. Defaults to \"small\".</p> <code>'small'</code> <code>project_goal</code> <code>str</code> <p>The goal of the project. Defaults to \"Tell a funny dad joke\".</p> <code>'Tell a funny dad joke'</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Team</code> <code>Team</code> <p>The team after running the workflow.</p> Source code in <code>libs\\teams.py</code> <pre><code>def run_team_workflow(\n    project_type: str = \"small\", project_goal: str = \"Tell a funny dad joke\", **kwargs\n) -&gt; Team:\n    \"\"\"Runs the team workflow for a given project type and goal.\n\n    Args:\n        project_type (str, optional): The type of the project. Defaults to \"small\".\n        project_goal (str, optional): The goal of the project. Defaults to \"Tell a funny dad joke\".\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Team: The team after running the workflow.\n    \"\"\"\n    project = Project(project_type, goal=project_goal)\n\n    # TODO: implement project-level workflows with multiple teams\n\n    # This selects the first team from a list of teams\n    team = project.teams[0]\n    team.goal = project_goal\n    team_graph = create_team_graph(team)\n    team_workflow = team_graph.compile()\n\n    member_names = team.fetch_member_names()\n    color_map = map_member_colors(member_names, color_names)\n\n    prior_submissions = []\n    for s in team_workflow.stream(team):\n        if \"__end__\" not in s:\n            for agent in team.fetch_member_names():\n                try:\n                    if \"Hello! I'm on team\" not in team.outputs.last[agent][\"message\"]:\n                        if team.outputs.last[agent][\"message\"] not in prior_submissions:\n                            print_heading(colored(agent, color=color_map[agent]))\n                            try:\n                                print_dict(\n                                    team.outputs.last[agent][\"message\"],\n                                    color=color_map[agent],\n                                )\n                            except:\n                                print(\n                                    colored(\n                                        team.outputs.last[agent][\"message\"],\n                                        color=color_map[agent],\n                                    )\n                                )\n                            prior_submissions.append(team.outputs.last[agent][\"message\"])\n\n                except Exception as e:\n                    print(\n                        \"---------------------------------------------------------------------------------\\n\"\n                    )\n                    print(colored(f\"An Exception occurred: {e}\", \"red\", attrs=[\"bold\"]))\n                    print(\n                        \"---------------------------------------------------------------------------------\\n\"\n                    )\n\n    return team\n</code></pre>"}]}